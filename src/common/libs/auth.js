"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

const electron = require("electron");
const events = require("events");
const googleapis = require("googleapis");
const querystring = require("querystring");
const url = require("url");
const BW = process.type === 'renderer' ? electron.remote.BrowserWindow : electron.BrowserWindow;

class UserClosedWindowError extends Error {
    constructor() {
        super('User closed the window');
    }
}
exports.UserClosedWindowError = UserClosedWindowError;

/**
 * Handle Google Auth processes through Electron.
 * This class automatically renews expired tokens.
 * @fires ElectronGoogleOAuth2#tokens
 */
class ElectronGoogleOAuth2 extends events.EventEmitter {
    /**
     * Create a new instance of ElectronGoogleOAuth2
     * @param {string} clientId - Google Client ID
     * @param {string} clientSecret - Google Client Secret
     * @param {string[]} scopes - Google scopes. 'profile' and 'email' will always be present
     * @param {string} redirectUri - defaults to 'urn:ietf:wg:oauth:2.0:oob'
     */
    constructor(clientId, clientSecret, scopes, redirectUri = 'urn:ietf:wg:oauth:2.0:oob') {
        super();
        // Always fetch id_token.
        if (!scopes.includes('profile'))
            scopes.push('profile');
        if (!scopes.includes('email'))
            scopes.push('email');
        this.scopes = scopes;
        this.clientId = clientId;
        this.clientSecret = clientSecret;

        this.oauth2Client = new googleapis.google.auth.OAuth2(clientId, clientSecret, redirectUri);
        this.oauth2Client.on('tokens', (tokens) => {
            this.emit('tokens', tokens);
        });
    }

    /**
     * Returns authUrl generated by googleapis
     *
     * @param {boolean} forceAddSession
     * @returns {string}
     */
    generateAuthUrl(forceAddSession = false) {
        let url = this.oauth2Client.generateAuthUrl({
            access_type: 'offline',
            scope: this.scopes,
        });
        if (forceAddSession) {
            const qs = querystring.stringify({ continue: url });
            url = `https://accounts.google.com/AddSession?${qs}`;
        }
        return url;
    }
    /**
     * Get authorization code for underlying authUrl
     *
     * @param {boolean} forceAddSession
     * @returns {Promise<string>}
     */
    async getAuthorizationCode(forceAddSession = false) {
        const url = this.generateAuthUrl(forceAddSession);
        return this.openAuthWindowAndGetAuthorizationCode(url);
    }

    /**
     * Get authorization code for given url
     * @param {string} urlParam
     * @returns {Promise<string>}
     */
    openAuthWindowAndGetAuthorizationCode(urlParam) {
        return new Promise((resolve, reject) => {
            const win = new BW({
                useContentSize: true,
                fullscreen: false,
            });
            win.loadURL(urlParam);
            win.on('closed', () => {
                reject(new UserClosedWindowError());
            });
            function closeWin() {
                win.removeAllListeners('closed');
                setImmediate(() => {
                    win.close();
                });
            }
            win.webContents.on('did-navigate', (_event, newUrl) => {
                const parsed = url.parse(newUrl, true);
                if (parsed.query.error) {
                    reject(new Error(parsed.query.error_description));
                    closeWin();
                }
                else if (parsed.query.code) {
                    resolve(parsed.query.code);
                    closeWin();
                }
            });
            win.on('page-title-updated', () => {
                setImmediate(() => {
                    const title = win.getTitle();
                    if (title.startsWith('Denied')) {
                        reject(new Error(title.split(/[ =]/)[2]));
                        closeWin();
                    }
                    else if (title.startsWith('Success')) {
                        resolve(title.split(/[ =]/)[2]);
                        closeWin();
                    }
                });
            });
        });
    }
    /**
     * Get Google tokens for given scopes
     * @param {boolean} forceAddSession
     * @returns {Promise<Credentials>}
     */
    async openAuthWindowAndGetTokens(forceAddSession = false) {

        var authorizationCode = await this.getAuthorizationCode(forceAddSession);
        var response = await this.oauth2Client.getToken(authorizationCode);
        this.oauthToken = response.tokens;
        this.oauth2Client.setCredentials(response.tokens);
        this.idToken = await this._verifyAndDecodeIDToken();
    }

    /**
     * Verify and decode the user token returned by the login.
     */
    async _verifyAndDecodeIDToken() {
        const ticket = await this.oauth2Client.verifyIdToken({
            idToken: this.oauthToken.id_token,
            audience: this.clientId,
        });
        return ticket.getPayload();
    }

    /**
     * Return the user's id token.
     */
    getIDToken() {
        return this.idToken;
    }

    /**
     * Set oauth2 client credentials to the given token.
     *
     * @param {object} tokens the credentials token
     */
    setTokens(tokens) {
        this.oauth2Client.setCredentials(tokens);
    }

    /**
     * Retrieve the Oauth 2 Client.
     */
    getClient() {
        return this.oauth2Client;
    }
}
exports.ElectronGoogleOAuth2 = ElectronGoogleOAuth2;
